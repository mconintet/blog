##更多的操作等待映射

操作（operators） 和移动（movements）是 Vim 中重要的部分之一，也是 Vim 如此高效的最大原因。我们将练习定义更多的移动，因为扩展这个有用的功能可以使得 Vim 更加的有用。

让我们假设你现在正在写一些 Markdown 文本。如果你之前还没有使用过 Markdown的话，别担心，为了达到我们的目的它在这里非常的简单。将下面的输入到一个文件中：

```
Topic One
=========

This is some text about topic one.

It has multiple paragraphs.

Topic Two
=========

This is some text about topic two.  It has only one paragraph.
```

那些以 `=` 作为“下划线”的行将被 Markdown 认为是标题。让我们创建更多的映射使得我们可以通过移动（movements）去定位到标题。运行下面的命令：

```vim
:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
```

这个映射是相当复杂的，所以先将你的光标放到其中的一个段落（非标题）上然后输入 `cih`。Vim 将会删除你所在段落的标题并将你带入插入模式（“修改标题内容”）。

映射使用了我们之前没有遇到过的一些东西，所以让我分别看看每一部分。第一部分是映射， `:onoremap ih` 这是映射命令，我们之前已经看过了，所以现在可以跳过它。现在我们也将跳过 `<c-u>`。

现在让我们看看余下的行内容：

```vim
:execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
```

##Normal 命令

那个 `:normal` 命令接收一些字符并以它们在普通模式下的行为去运行它们。我们将在以后的章节中更加深入的了解它，不过我们已经遇到它们很多次了，所以是时候尝试一下它了。运行下面的命令：

```vim
:normal gg
```

Vim 将会带你移动到文件的开头。现在运行下面的命令：

```vim
:normal >>
```

Vim 将会缩进当前行。

现在，不必但因我们映射中 `:normal` 后面的 `!`。我们以后将会讨论到它。

##Execute 命令

`Execute` 命令接收一个 Vimscript 字符串（我们之后将会讨论到）并执行它。运行下面的命令：

```vim
:execute "write"
```

Vim 将会写入当前文件，就好像你输入了 `:write<cr>`。现在运行下面的命令：

```vim
:execute "normal! gg"
```

Vim 将会运行 `:normal! gg`，这也会将你移动到文件的开头。但是很奇怪，为什么我们不能直接运行 `normal!` 命令？

看看下面的命令，试一试并猜猜看它做了什么：

```vim
:normal! gg/a<cr>
```

它看起啦好像是：
- 移动到文件开头。
- 开始一个搜索。
- 以 "a" 为搜索目标。
- 按下回车去执行搜索。

运行它。Vim 将会移动到文件开头，除此之外没了。

问题就在于 `normal!` 不认识类似 `<cr>` 之类的 “特殊字符（special characters）”。有很多方式去绕过这个问题，但是最简单去使用和易读的方式就是 `execute`。

当 `execute` 接收到你让其运行的字符串时，在运行这些字符串*之前*会对它们做替换。在这个例子中，`\r` 是一个逃脱序列（ escape sequence ）表示“回车（carriage return）”。两个反斜杠也是一个逃脱序列，表示将一个反斜杠放到字符串中。

如果我们将这些转换带入到我们的映射中再去看看，就会知道映射到底执行了什么：

```
:normal! ?^==\+$<cr>:nohlsearch<cr>kvg_
                ^^^^           ^^^^
                 ||             ||
这些是真正的回车，而不是四个分开的字符：小于号，字符 "c"，字符 "r"，大于号。
```

所以现在 `normal!` 将会按照我们在普通模式下输入了它们的情况去运行它们。让我们以回车分隔下，去找出我们干了什么：

```
?^==\+$
:nohlsearch
kvg_
```

第一部分，`?^==\+$`执行了一个向后搜索，找到一行中只有等号的行。这会将我的光标放置在目标行的第一个字符，也就是第一个等号上。

我们执行向后搜索的原因是，我们说要在当前段落的标题中去“改变标题内容，所以我们要改变当前段落的标题，而不是下一个段落的标题。

第二个部分是 `:nohlsearch` 命令。它就是简单的清除搜索结果的高亮显示，以使我们不会分散注意力。

最后一部分是有三个普通模式命令组成的序列：
- `k`：上移一行。因为之前我们在等号行的第一个等号上，现在我们位于了标题文本的第一个字符。
- `v`：进入可视模式
- `g_`：移动到当前行的最后一个非空白字符。我们不使用 `$` 是因为它会包含并高亮换行符，这不是我们需要的。

##结果

我们花了很多工作去了解映射的每一部分。现在概况一下：
- 我们为”段落标题内容“创建了一个操作等待映射。
- 我们使用了 `execute` 和 `normal!` 去运行普通命令以选择标题，并避免在普通命令中使用特殊字符。
- 我们的映射找出全是等号的行，并选中了它上面的标题内容。
- Vim 接手了剩下的内容。

在继续前景之前让我们再看一个映射。运行下面的命令：

```vim
:onoremap ah :<c-u>execute "normal! ?^==\\+\r:nohlsearch\rg_vk0"<cr>
```

将你的光标放置到段落中并输入 `cah`。这次 Vim 不光删除了标题的文本内容，而且删除了文本下方的等号行。你可以认为它是”段落的整个标题“。

这些映射中有什么不同？让我们一步步看看：

```vim
:onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
:onoremap ah :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rg_vk0"<cr>
```

唯一的不同就是结尾部分，我们用于选择文本的操作：

```
inside heading: kvg_
around heading: g_vk0
```

其余的部分是相同的，所以我们还是以等号行的第一个等号字符开始的，接下来：
- `g_`：移动到行尾最后一个非空白字符
- `v`：进入可视模式
- `k`：上移一行。这会将我们带到标题内容的行
- `0`：移动到行首

结果就是标题文本和其下面的等号行都被选中了，接下来 Vim 将操作应用于它们。

##练习

Markdown 还支持以 `-` 作为标题的界限。在映射中使用正则去适配这个情况。你可能需要查看 `:help pattern-overview`。记住正则是在字符串中的，所以反斜杠需要被转移。

添加两个自动到你的 `~/.vimrc` 文件以此去创建上面的映射。确保这些自动命令只适用于合适的缓冲区，并且将它们分组以防止你在应用配置文件的时候重复定义它们。

阅读 `:help normal`

阅读 `:help execute`

阅读 `:help expr-quote` 去查看你可以在字符串中使用的跳脱序列。

为“下一个email地址内容”去创建一个操作等待映射，这样你就可以“修改下一个email地址”。`in@` 可以作为映射的一个比较好的候选按键。对此你可能需要使用 `/...some regexp...<cr>`。
